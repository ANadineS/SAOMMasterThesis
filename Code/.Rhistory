}, error = function(e) {
print(paste("Error occurred in iteration", x[1]))
print(e)
print(traceback())
return(NULL)
})
}
SafeSimulation <- function(x){
tryCatch({
SimulationRun(IntroduceError_Random, netwmatrices[[1]], second_observations[[x[1]]], sex2, controls, x[3], x[2])
}, error = function(e) {
print(paste("Error occurred in iteration", x[1]))
print(e)
print(traceback())
return(NULL)
})
}
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# Load R Packages
library(RSiena)
library(dplyr)
library(ggplot2)
library(igraph)
library(sna)
library(network)
library(RColorBrewer)
library(GGally)
library(reshape2)
library(parallel)
# Load Data
load("../Data/Input/Glasgow-friendship.RData")
load("../Data/Input/Glasgow-demographic.RData")
# Source Scripts
source("./SimulationRun.R")
source("./HelperFunctions.R")
source("./FormatOutput.R")
# Only select actors that are active participants in both wave 2 and 3
noresponse_1 <- apply(friendship.2, 1, function(row) all(is.na(row) | row == 10))
noresponse_2 <- apply(friendship.3, 1, function(row) all(is.na(row) | row == 10))
inactive <- noresponse_1 | noresponse_2
netwmatrices <- list(friendship.2[!inactive, !inactive], friendship.3[!inactive, !inactive]) %>%
lapply(., function(x) apply(x,1, function(y) replace(y,y == 2, 1))) # Create network without weights
# Coding sex as 0/1
sex <- ifelse(sex.F[!inactive] == 1, 0, 1)
sex2 <- coCovar(sex, centered = F)
friendship <- sienaDependent(array(c(netwmatrices[[1]], netwmatrices[[2]]),
dim = c(133,133,2)))
glasgowdata <- sienaDataCreate(friendship, sex2)
effects <- getEffects(glasgowdata)
effects <- includeEffects(effects, name = "friendship",
density, recip, cycle3, gwespFF, transRecTrip, inPop, inAct)
effects <- includeEffects(effects, name = "friendship", sameX, interaction1 = "sex2")
realmodel <- siena07(controls, data = glasgowdata, effects = effects)
controls <- sienaAlgorithmCreate(seed = 2809)
# Real Model
friendship <- sienaDependent(array(c(netwmatrices[[1]], netwmatrices[[2]]),
dim = c(133,133,2)))
glasgowdata <- sienaDataCreate(friendship, sex2)
effects <- getEffects(glasgowdata)
effects <- includeEffects(effects, name = "friendship",
density, recip, cycle3, gwespFF, transRecTrip, inPop, inAct)
effects <- includeEffects(effects, name = "friendship", sameX, interaction1 = "sex2")
realmodel <- siena07(controls, data = glasgowdata, effects = effects)
# Second Observations
set.seed(2809)
simulation_controls <- sienaAlgorithmCreate(n3 = 500, nsub = 0)
simulations <- siena07(simulation_controls, data = glasgowdata, effects = effects,
returnDeps = T, prevAns = realmodel)
second_observations_list <- lapply(lapply(lapply(simulations$sims, "[[", "Data1"), "[[", "friendship"),
"[[", "1")
second_observations <- lapply(second_observations_list, function(x)
as_adjacency_matrix(graph_from_edgelist(as.matrix(x[,-3]), directed = T)))
saveRDS(realmodel, "../Data/Output/RealModel.RData")
saveRDS(second_observations, "../Data/Output/SecondObservations.RData")
SafeSimulation <- function(x){
tryCatch({
SimulationRun(IntroduceError_Random, netwmatrices[[1]], second_observations[[x[1]]], sex2, controls, x[3], x[2])
}, error = function(e) {
print(paste("Error occurred in iteration", x[1]))
print(e)
print(traceback())
return(NULL)
})
}
n <- 500
neg_error <- c(0.1)
pos_error <- 0
simulation_element <- expand.grid(1:n, neg_error, pos_error)
cl <- makeCluster(detectCores())
clusterExport(cl, c("SafeSimulation", "SimulationRun", "IntroduceError_Random", "second_observations", "netwmatrices", "sex2", "controls", "simulation_element", "ChangeCoding"))
clusterEvalQ(cl, {library(igraph); library(RSiena)})
random_output <- parApply(cl, MARGIN = 1, X = as.matrix(simulation_element), FUN = SafeSimulation(simulation_element))
SafeSimulation <- function(x){
tryCatch({
SimulationRun(IntroduceError_Random, netwmatrices[[1]], second_observations[[x[1]]], sex2, controls, x[3], x[2])
}, error = function(e) {
print(paste("Error occurred in iteration", x[1]))
print(e)
print(traceback())
return(NULL)
})
}
n <- 500
neg_error <- c(0.1)
pos_error <- 0
simulation_element <- expand.grid(1:n, neg_error, pos_error)
cl <- makeCluster(detectCores())
clusterExport(cl, c("SafeSimulation", "SimulationRun", "IntroduceError_Random", "second_observations", "netwmatrices", "sex2", "controls", "simulation_element", "ChangeCoding"))
clusterEvalQ(cl, {library(igraph); library(RSiena)})
random_output <- parApply(cl, MARGIN = 1, X = as.matrix(simulation_element), FUN = SafeSimulation)
SafeSimulation <- function(x){
tryCatch({
SimulationRun(IntroduceError_Random, netwmatrices[[1]], second_observations[[x[1]]], sex2, controls, x[3], x[2])
}, error = function(e) {
print(paste("Error occurred in iteration", x[1]))
print(e)
print(traceback())
return(NULL)
})
}
n <- 10
neg_error <- c(0.1)
pos_error <- 0
simulation_element <- expand.grid(1:n, neg_error, pos_error)
cl <- makeCluster(detectCores())
clusterExport(cl, c("SafeSimulation", "SimulationRun", "IntroduceError_Random", "second_observations", "netwmatrices", "sex2", "controls", "simulation_element", "ChangeCoding"))
clusterEvalQ(cl, {library(igraph); library(RSiena)})
random_output <- parApply(cl, MARGIN = 1, X = as.matrix(simulation_element), FUN = SafeSimulation)
#random_output <- parApply(cl, MARGIN = 1, X = as.matrix(simulation_element), FUN = function(x) SimulationRun(IntroduceError_Random, netwmatrices[[1]], second_observations[[x[1]]], sex2, controls, x[3], x[2]))
stopCluster(cl)
saveRDS(random_output, "../Data/Output/01_Random_Raw_Output.RData")
View(random_output)
random_output <- readRDS("../Data/Output/01_Random_Raw_Output.RData")
random_formatted <- FormatOutput(random_output)
saveRDS(random_formatted, "../Data/Output/01_Random_Formatted_Output.RData")
warnings()
random_formatted$theta
output <- random_formatted
error_combo <- expand.grid(neg_error, pos_error)
NetworkSummary <- function(networklist){
netwobjects <- lapply(networklist, function(x)
network(as.matrix(x), directed = T, matrix.type = "adjacency"))
netwstats <- data.frame(
"Network size" = sapply(netwobjects, network.size),
"Density" = sapply(netwobjects, gden),
"Components" = sapply(netwobjects, components),
"Transitivity" = sapply(netwobjects, function(x) gtrans(x, mode = "graph")),
"Reciprocity" = sapply(netwobjects, function(x) grecip (x, measure = "edgewise"))
)
return(netwstats)
}
for (i in 1:nrow(error_combo)){
indices <- ((i-1)*(n)+1):n*i
obs_1 <- lapply(output$original_networks[indices], function(arr) arr[,,1])
obs_2 <- lapply(output$original_networks[indices], function(arr) arr[,,2])
an_1 <- lapply(output$analyzed_networks[indices], function(arr) arr[,,1])
an_2 <- lapply(output$analyzed_networks[indices], function(arr) arr[,,2])
View(NetworkSummary(obs_2))
}
networklist <- lapply(output$original_networks[indices], function(arr) arr[,,2])
length(networklist)
NetworkSummary(obs_2)
identical(obs_2[[1]], obs_2[[2]])
netwobjects <- lapply(networklist, function(x)
network(as.matrix(x), directed = T, matrix.type = "adjacency"))
identical(netwobjcts[[1]], netwobjects[[2]])
identical(netwobjects[[1]], netwobjects[[2]])
identical(netwobjects[[9]], netwobjects[[2]])
View(NetworkSummary(an_2))
View(NetworkSummary(obs_2))
View(obs_2[[1]])
identical(as.matrix(networklist[[1]]), as.matrix(networklist[[2]]))
identical(network(as.matrix(networklist[[1]]), directed = T, matrix.type = "adjacency"), network(as.matrix(networklist[[2]], directed = T, matrix.type = "adjacency")))
network(as.matrix(networklist[[1]]), directed = T, matrix.type = "adjacency")
network(as.matrix(networklist[[2]]), directed = T, matrix.type = "adjacency")
identical(network(as.matrix(networklist[[1]]), directed = T, matrix.type = "adjacency"), network(as.matrix(networklist[[2]]), directed = T, matrix.type = "adjacency"))
?network
View(as.matrix(networklist[[1]]))
View(as.matrix(networklist[[2]]))
?tryCatch
second_observations
identical(network(second_observations[[1]], directed = T, matrix.type = "adjacency"), network(second_observations[[2]], directed = T, matrix.type = "adjacency"))
simulation_element[1,]
simulation_element[2,]
# Source Scripts
source("./SimulationRun.R")
# Source Scripts
source("./SimulationRun.R")
SafeSimulation <- function(x){
tryCatch({
SimulationRun(IntroduceError_Random, netwmatrices[[1]], second_observations[[x[1]]], sex2, controls, x[3], x[2], simulation_element)
}, error = function(e) {
print(paste("Error occurred in iteration", x[1]))
print(e)
print(traceback())
return(NULL)
})
}
n <- 10
neg_error <- c(0.1)
pos_error <- 0
simulation_element <- expand.grid(1:n, neg_error, pos_error)
cl <- makeCluster(detectCores())
clusterExport(cl, c("SafeSimulation", "SimulationRun", "IntroduceError_Random", "second_observations", "netwmatrices", "sex2", "controls", "simulation_element", "ChangeCoding"))
clusterEvalQ(cl, {library(igraph); library(RSiena)})
random_output <- parApply(cl, MARGIN = 1, X = as.matrix(simulation_element), FUN = SafeSimulation)
#random_output <- parApply(cl, MARGIN = 1, X = as.matrix(simulation_element), FUN = function(x) SimulationRun(IntroduceError_Random, netwmatrices[[1]], second_observations[[x[1]]], sex2, controls, x[3], x[2]))
stopCluster(cl)
SimulationRun <- function(IntroduceError_X, obs1, obs2, sex, controls, error_pos, error_neg, simulation_element){
cat(simulation_element)
netw_1 <- IntroduceError_X(obs1, error_neg, error_pos)
netw_2 <- IntroduceError_X(obs2, error_neg, error_pos)
actualchange <- ChangeCoding(obs1, obs2)
analyzedchange <- ChangeCoding(netw_1, netw_2)
error_in_change <- sum(actualchange != analyzedchange)/(nrow(actualchange)^2-length(diag(actualchange)))
friendship <- sienaDependent(array(c(netw_1, netw_2), dim = c(133,133,2)))
glasgowdata <- sienaDataCreate(friendship, sex2)
effects <- getEffects(glasgowdata)
effects <- includeEffects(effects, name = "friendship", density, recip, cycle3, gwespFF, transRecTrip, inPop, inAct)
effects <- includeEffects(effects, name = "friendship", sameX, interaction1 = "sex2")
results <- siena07(controls, data = glasgowdata, effects = effects)
output <- list()
output$original_networks <- array(c(obs1, obs2), dim = c(133,133,2))
output$analyzed_networks <- array(c(netw_1, netw_2), dim = c(133,133,2))
output$actualchange <- actualchange
output$analyzedchange <- analyzedchange
output$error_neg <- error_neg
output$error_pos <- error_pos
output$error_in_change <- error_in_change
output$results <- results
output$theta <- c(results$rate, results$theta)
output$se <- c(results$vrate, results$se)
return(output)
}
# Source Scripts
source("./SimulationRun.R")
SafeSimulation <- function(x){
tryCatch({
SimulationRun(IntroduceError_Random, netwmatrices[[1]], second_observations[[x[1]]], sex2, controls, x[3], x[2], simulation_element)
}, error = function(e) {
print(paste("Error occurred in iteration", x[1]))
print(e)
print(traceback())
return(NULL)
})
}
n <- 10
neg_error <- c(0.1)
pos_error <- 0
simulation_element <- expand.grid(1:n, neg_error, pos_error)
cl <- makeCluster(detectCores())
clusterExport(cl, c("SafeSimulation", "SimulationRun", "IntroduceError_Random", "second_observations", "netwmatrices", "sex2", "controls", "simulation_element", "ChangeCoding"))
clusterEvalQ(cl, {library(igraph); library(RSiena)})
random_output <- parApply(cl, MARGIN = 1, X = as.matrix(simulation_element), FUN = SafeSimulation)
#random_output <- parApply(cl, MARGIN = 1, X = as.matrix(simulation_element), FUN = function(x) SimulationRun(IntroduceError_Random, netwmatrices[[1]], second_observations[[x[1]]], sex2, controls, x[3], x[2]))
stopCluster(cl)
saveRDS(random_output, "../Data/Output/01_Random_Raw_Output.RData")
# Source Scripts
source("./SimulationRun.R")
SafeSimulation <- function(x){
tryCatch({
SimulationRun(IntroduceError_Random, netwmatrices[[1]], second_observations[[x[1]]], sex2, controls, x[3], x[2], simulation_element)
}, error = function(e) {
print(paste("Error occurred in iteration", x[1]))
print(e)
print(traceback())
return(NULL)
})
}
n <- 10
neg_error <- c(0.1)
pos_error <- 0
simulation_element <- expand.grid(1:n, neg_error, pos_error)
cl <- makeCluster(detectCores())
clusterExport(cl, c("SafeSimulation", "SimulationRun", "IntroduceError_Random", "second_observations", "netwmatrices", "sex2", "controls", "simulation_element", "ChangeCoding"))
clusterEvalQ(cl, {library(igraph); library(RSiena)})
random_output <- parApply(cl, MARGIN = 1, X = as.matrix(simulation_element), FUN = SafeSimulation)
#random_output <- parApply(cl, MARGIN = 1, X = as.matrix(simulation_element), FUN = function(x) SimulationRun(IntroduceError_Random, netwmatrices[[1]], second_observations[[x[1]]], sex2, controls, x[3], x[2]))
stopCluster(cl)
saveRDS(random_output, "../Data/Output/01_Random_Raw_Output.RData")
random_output[[3]]
SafeSimulation <- function(x){
tryCatch({
SimulationRun(IntroduceError_Random, netwmatrices[[1]], second_observations[[x[1]]], sex2, controls, x[3], x[2], x)
}, error = function(e) {
print(paste("Error occurred in iteration", x[1]))
print(e)
print(traceback())
return(NULL)
})
}
n <- 10
neg_error <- c(0.1)
pos_error <- 0
simulation_element <- expand.grid(1:n, neg_error, pos_error)
cl <- makeCluster(detectCores())
clusterExport(cl, c("SafeSimulation", "SimulationRun", "IntroduceError_Random", "second_observations", "netwmatrices", "sex2", "controls", "simulation_element", "ChangeCoding"))
clusterEvalQ(cl, {library(igraph); library(RSiena)})
random_output <- parApply(cl, MARGIN = 1, X = as.matrix(simulation_element), FUN = SafeSimulation)
#random_output <- parApply(cl, MARGIN = 1, X = as.matrix(simulation_element), FUN = function(x) SimulationRun(IntroduceError_Random, netwmatrices[[1]], second_observations[[x[1]]], sex2, controls, x[3], x[2]))
stopCluster(cl)
saveRDS(random_output, "../Data/Output/01_Random_Raw_Output.RData")
random_output[[4]]
identical(random_output[[3]]$original_networks[,,2], second_observations[[3]])
SimulationRun <- function(IntroduceError_X, obs1, obs2, sex, controls, error_pos, error_neg, simulation_element){
netw_1 <- IntroduceError_X(obs1, error_neg, error_pos)
netw_2 <- IntroduceError_X(obs2, error_neg, error_pos)
actualchange <- ChangeCoding(obs1, obs2)
analyzedchange <- ChangeCoding(netw_1, netw_2)
error_in_change <- sum(actualchange != analyzedchange)/(nrow(actualchange)^2-length(diag(actualchange)))
friendship <- sienaDependent(array(c(netw_1, netw_2), dim = c(133,133,2)))
glasgowdata <- sienaDataCreate(friendship, sex2)
effects <- getEffects(glasgowdata)
effects <- includeEffects(effects, name = "friendship", density, recip, cycle3, gwespFF, transRecTrip, inPop, inAct)
effects <- includeEffects(effects, name = "friendship", sameX, interaction1 = "sex2")
results <- siena07(controls, data = glasgowdata, effects = effects)
output <- list()
output$original_networks_1 <- obs1
output$original_networks_2 <- obs2
output$analyzed_networks <- array(c(netw_1, netw_2), dim = c(133,133,2))
output$actualchange <- actualchange
output$analyzedchange <- analyzedchange
output$error_neg <- error_neg
output$error_pos <- error_pos
output$error_in_change <- error_in_change
output$results <- results
output$theta <- c(results$rate, results$theta)
output$se <- c(results$vrate, results$se)
output$el <- simulation_element
return(output)
}
# Source Scripts
source("./SimulationRun.R")
SafeSimulation <- function(x){
tryCatch({
SimulationRun(IntroduceError_Random, netwmatrices[[1]], second_observations[[x[1]]], sex2, controls, x[3], x[2], x)
}, error = function(e) {
print(paste("Error occurred in iteration", x[1]))
print(e)
print(traceback())
return(NULL)
})
}
n <- 10
neg_error <- c(0.1)
pos_error <- 0
simulation_element <- expand.grid(1:n, neg_error, pos_error)
cl <- makeCluster(detectCores())
clusterExport(cl, c("SafeSimulation", "SimulationRun", "IntroduceError_Random", "second_observations", "netwmatrices", "sex2", "controls", "simulation_element", "ChangeCoding"))
clusterEvalQ(cl, {library(igraph); library(RSiena)})
random_output <- parApply(cl, MARGIN = 1, X = as.matrix(simulation_element), FUN = SafeSimulation)
#random_output <- parApply(cl, MARGIN = 1, X = as.matrix(simulation_element), FUN = function(x) SimulationRun(IntroduceError_Random, netwmatrices[[1]], second_observations[[x[1]]], sex2, controls, x[3], x[2]))
stopCluster(cl)
saveRDS(random_output, "../Data/Output/01_Random_Raw_Output.RData")
# Source Scripts
source("./SimulationRun.R")
SafeSimulation <- function(x){
tryCatch({
SimulationRun(IntroduceError_Random, netwmatrices[[1]], second_observations[[x[1]]], sex2, controls, x[3], x[2], x)
}, error = function(e) {
print(paste("Error occurred in iteration", x[1]))
print(e)
print(traceback())
return(NULL)
})
}
n <- 10
neg_error <- c(0.1)
pos_error <- 0
simulation_element <- expand.grid(1:n, neg_error, pos_error)
cl <- makeCluster(detectCores())
clusterExport(cl, c("SafeSimulation", "SimulationRun", "IntroduceError_Random", "second_observations", "netwmatrices", "sex2", "controls", "simulation_element", "ChangeCoding"))
clusterEvalQ(cl, {library(igraph); library(RSiena)})
random_output <- parApply(cl, MARGIN = 1, X = as.matrix(simulation_element), FUN = SafeSimulation)
#random_output <- parApply(cl, MARGIN = 1, X = as.matrix(simulation_element), FUN = function(x) SimulationRun(IntroduceError_Random, netwmatrices[[1]], second_observations[[x[1]]], sex2, controls, x[3], x[2]))
stopCluster(cl)
saveRDS(random_output, "../Data/Output/01_Random_Raw_Output.RData")
View(random_output[[3]]$original_networks_2)
View(as.matrix(random_output[[3]]$original_networks_2))
source("./FormatOutput.R")
random_output <- readRDS("../Data/Output/01_Random_Raw_Output.RData")
random_formatted <- FormatOutput(random_output)
saveRDS(random_formatted, "../Data/Output/01_Random_Formatted_Output.RData")
output <- random_formatted
for (i in 1:nrow(error_combo)){
indices <- ((i-1)*(n)+1):n*i
obs_1 <- output$original_networks_1[indices]
obs_2 <- output$original_networks_2[indices]
an_1 <- lapply(output$analyzed_networks[indices], function(arr) arr[,,1])
an_2 <- lapply(output$analyzed_networks[indices], function(arr) arr[,,2])
View(NetworkSummary(obs_2))
}
SafeSimulation <- function(x){
tryCatch({
SimulationRun(IntroduceError_Random, netwmatrices[[1]], second_observations[[x[1]]], sex2, controls, x[3], x[2], x)
}, error = function(e) {
print(paste("Error occurred in iteration", x[1]))
print(e)
print(traceback())
return(NULL)
})
}
n <- 500
neg_error <- c(0.1, 0.2)
pos_error <- 0
simulation_element <- expand.grid(1:n, neg_error, pos_error)
cl <- makeCluster(detectCores())
clusterExport(cl, c("SafeSimulation", "SimulationRun", "IntroduceError_Random", "second_observations", "netwmatrices", "sex2", "controls", "simulation_element", "ChangeCoding"))
clusterEvalQ(cl, {library(igraph); library(RSiena)})
random_output <- parApply(cl, MARGIN = 1, X = as.matrix(simulation_element), FUN = SafeSimulation)
#random_output <- parApply(cl, MARGIN = 1, X = as.matrix(simulation_element), FUN = function(x) SimulationRun(IntroduceError_Random, netwmatrices[[1]], second_observations[[x[1]]], sex2, controls, x[3], x[2]))
stopCluster(cl)
saveRDS(random_output, "../Data/Output/01_Random_Raw_Output.RData")
length(random_output)
View(random_output)
sum(is.null(random_output))
sum(lapply(random_output, is.null))
sum(sapply(random_output, is.null))
clean <- Filter(Negate(is.null), random_output)
length(clean)
random_formatted <- FormatOutput(random_output)
random_formatted <- FormatOutput(clean)
NetworkSummary <- function(networklist){
netwobjects <- lapply(networklist, function(x)
network(as.matrix(x), directed = T, matrix.type = "adjacency"))
netwstats <- data.frame(
"Network size" = sapply(netwobjects, network.size),
"Density" = sapply(netwobjects, gden),
"Components" = sapply(netwobjects, components),
"Transitivity" = sapply(netwobjects, function(x) gtrans(x, mode = "graph")),
"Reciprocity" = sapply(netwobjects, function(x) grecip (x, measure = "edgewise"))
)
return(netwstats)
}
stats_per_network <- vector("list", nrow(error_combo))
output <- random_formatted
for (i in 1:nrow(error_combo)){
indices <- ((i-1)*(n)+1):n*i
stats_error_combo <- list(
obs_1 = NetworkSummary(output$original_networks_1[indices]),
obs_2 = NetworkSummary(output$original_networks_2[indices]),
an_1 = NetworkSummary(lapply(output$analyzed_networks[indices], function(arr) arr[,,1])),
an_2 = NetworkSummary(lapply(output$analyzed_networks[indices], function(arr) arr[,,2]))
)
stats_per_network[[i]] <- setNames(stats_error_combo, paste0("Error", error_combo[1,]))
}
View(stats_per_network)
stats_per_network
stats_per_network <- vector("list", nrow(error_combo))
for (i in 1:nrow(error_combo)){
indices <- ((i-1)*(n)+1):n*i
stats_error_combo <- list(
obs_1 = NetworkSummary(output$original_networks_1[indices]),
obs_2 = NetworkSummary(output$original_networks_2[indices]),
an_1 = NetworkSummary(lapply(output$analyzed_networks[indices], function(arr) arr[,,1])),
an_2 = NetworkSummary(lapply(output$analyzed_networks[indices], function(arr) arr[,,2]))
)
stats_per_network[[i]] <- setNames(stats_error_combo, paste0("Error_", error_combo[i,1], "-", error_combo[i,2]))
}
stats_per_network
length(stats_per_network)
error_combo <- expand.grid(neg_error, pos_error)
error_combo
stats_per_network <- vector("list", nrow(error_combo))
for (i in 1:nrow(error_combo)){
indices <- ((i-1)*(n)+1):n*i
stats_error_combo <- list(
obs_1 = NetworkSummary(output$original_networks_1[indices]),
obs_2 = NetworkSummary(output$original_networks_2[indices]),
an_1 = NetworkSummary(lapply(output$analyzed_networks[indices], function(arr) arr[,,1])),
an_2 = NetworkSummary(lapply(output$analyzed_networks[indices], function(arr) arr[,,2]))
)
stats_per_network[[i]] <- setNames(stats_error_combo, paste0("Error_", error_combo[i,1], "_", error_combo[i,2]))
}
for (i in 1:nrow(error_combo)){
print(error_combo[i,])
indices <- ((i-1)*(n)+1):n*i
print(indices)
stats_error_combo <- list(
obs_1 = NetworkSummary(output$original_networks_1[indices]),
obs_2 = NetworkSummary(output$original_networks_2[indices]),
an_1 = NetworkSummary(lapply(output$analyzed_networks[indices], function(arr) arr[,,1])),
an_2 = NetworkSummary(lapply(output$analyzed_networks[indices], function(arr) arr[,,2]))
)
stats_per_network[[i]] <- setNames(stats_error_combo, paste0("Error_", error_combo[i,1], "_", error_combo[i,2]))
}
indices
n
n
(2-1)*n+1
for (i in 1:nrow(error_combo)){
print(error_combo[i,])
indices <- ((i-1)*(n)+1):(n*i)
print(indices)
stats_error_combo <- list(
obs_1 = NetworkSummary(output$original_networks_1[indices]),
obs_2 = NetworkSummary(output$original_networks_2[indices]),
an_1 = NetworkSummary(lapply(output$analyzed_networks[indices], function(arr) arr[,,1])),
an_2 = NetworkSummary(lapply(output$analyzed_networks[indices], function(arr) arr[,,2]))
)
stats_per_network[[i]] <- setNames(stats_error_combo, paste0("Error_", error_combo[i,1], "_", error_combo[i,2]))
}
indices
View(output$original_networks_1[indices])
NetworkSummary(output$original_networks_1[indices])
output$original_networks_1[indices-500]
NetworkSummary(output$original_networks_1[indices])
View(output$original_networks_1[501:1000])
View(random_foramtted)
View(random_formatted)
View(random_formatted$error_neg)
View(random_formatted$original_networks_1)
