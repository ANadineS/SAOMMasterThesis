second_observations[500]
stopCluster(cl)
simulation_element <- expand.grid(1:500, 0.1, 0)
cl <- makeCluster(detectCores()-1)
clusterExport(cl, c("SimulationRun", "IntroduceError_Random", "second_observations", "netwmatrices", "sex2", "controls", "simulation_element", "ChangeCoding"))
clusterEvalQ(cl, {library(igraph); library(RSiena)})
random_output <- parApply(cl, MARGIN = 1, X = as.matrix(simulation_element), FUN = function(x) SimulationRun(IntroduceError_Random, netwmatrices[[1]], second_observations[[x[1]]], sex2, controls, x[3], x[2]))
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# Load R Packages
library(RSiena)
library(dplyr)
library(ggplot2)
library(igraph)
library(sna)
library(network)
library(RColorBrewer)
library(GGally)
library(reshape2)
library(parallel)
# Load Data
load("../Data/Input/Glasgow-friendship.RData")
load("../Data/Input/Glasgow-demographic.RData")
# Source Scripts
source("./SimulationRun.R")
source("./HelperFunctions.R")
source("./FormatOutput.R")
random_output <- readRDS("../Data/Output/01_Random_Raw_Output.RData")
random_output <- readRDS("../Data/Output/01_Random_Raw_Output.RData")
random_formatted <- FormatOutput(random_output)
saveRDS(random_formatted, "01_Random_Formatted_Output.RData")
names(random_formatted)
?split
output <- random_formatted
splitbyerror  <- split(output ~ error_neg + error_pos)
splitbyerror  <- split(output, output ~ error_neg + error_pos)
splitbyerror  <- split(output, list(output$error_neg, outupt$error_pos))
splitbyerror  <- split(output, list(output$error_neg, output$error_pos))
splitbyerror  <- split(output, list(as.factor(output$error_neg), as.factor(output$error_pos)))
splitbyerror  <- split(output, output$error_neg)
splitbyerror  <- split(output, ~ output$error_neg + outupt$error_pos)
splitbyerror
splitthetabyerror  <- split(output$theta, ~ output$error_neg + outupt$error_pos)
splitthetabyerror  <- split(output$theta, ~ output$error_neg + output$error_pos)
View(splitthetabyerror)
error_combos <- unique(output$error_neg + output$error_pos)
error_combos
error_combos <- unique(~ output$error_neg + output$error_pos)
error_combo <- expand.grid(neg_error, pos_error)
n <- 500
neg_error <- c()
pos_error <- 0
error_combo <- expand.grid(neg_error, pos_error)
names(random_output)
random_formatted
names(random_formatted)
names(output)
output[[1:500]]
output$original_networks[[1:500]]
a <- output$original_networks
a[[1:500]]
a
names(output$original_networks[[1]])
a
b < a[[1]]
b <- a[[1]]
b
b[1,,]
b[,,1]
original_networks <- lapply(output$original_networks, function(arr) arr[,,1])
b <- original_networks[[1:500]]
b
length(b)
output$original_networks[1:500]
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# Load R Packages
library(RSiena)
library(dplyr)
library(ggplot2)
library(igraph)
library(sna)
library(network)
library(RColorBrewer)
library(GGally)
library(reshape2)
library(parallel)
# Load Data
load("../Data/Input/Glasgow-friendship.RData")
load("../Data/Input/Glasgow-demographic.RData")
# Source Scripts
source("./SimulationRun.R")
source("./HelperFunctions.R")
source("./FormatOutput.R")
# Only select actors that are active participants in both wave 2 and 3
noresponse_1 <- apply(friendship.2, 1, function(row) all(is.na(row) | row == 10))
noresponse_2 <- apply(friendship.3, 1, function(row) all(is.na(row) | row == 10))
inactive <- noresponse_1 | noresponse_2
netwmatrices <- list(friendship.2[!inactive, !inactive], friendship.3[!inactive, !inactive]) %>%
lapply(., function(x) apply(x,1, function(y) replace(y,y == 2, 1))) # Create network without weights
# Coding sex as 0/1
sex <- ifelse(sex.F[!inactive] == 1, 0, 1)
sex2 <- coCovar(sex, centered = F)
set.seed(2809)
controls <- sienaAlgorithmCreate(seed = 2809)
# Creating "Real" SAOM model & second observations generated based on the second model
if (file.exists("../Data/Output/RealModel.RData")){
realmodel <- readRDS("../Data/Output/RealModel.RData")
second_observations <- readRDS("../Data/Output/SecondObservations.RData")
} else{
# Real Model
friendship <- sienaDependent(array(c(netwmatrices[[1]], netwmatrices[[2]]),
dim = c(133,133,2)))
glasgowdata <- sienaDataCreate(friendship, sex2)
effects <- getEffects(glasgowdata)
effects <- includeEffects(effects, name = "friendship",
density, recip, cycle3, gwespFF, transRecTrip, inPop, inAct)
effects <- includeEffects(effects, name = "friendship", sameX, interaction1 = "sex2")
realmodel <- siena07(controls, data = glasgowdata, effects = effects)
# Second Observations
simulation_controls <- sienaAlgorithmCreate(n3 = 500, nsub = 0, seed = 2809)
simulations <- siena07(simulation_controls, data = glasgowdata, effects = effects,
returnDeps = T, prevAns = realmodel)
second_observations_list <- lapply(lapply(lapply(simulations$sims, "[[", "Data1"), "[[", "friendship"),
"[[", "1")
second_observations <- lapply(second_observations_list, function(x)
as_adjacency_matrix(graph_from_edgelist(as.matrix(x[,-3]), directed = T)))
saveRDS(realmodel, "../Data/Output/RealModel.RData")
saveRDS(second_observations, "../Data/Output/SecondObservations.RData")
}
random_output <- readRDS("../Data/Output/01_Random_Raw_Output.RData")
random_formatted <- FormatOutput(random_output)
saveRDS(random_formatted, "../Data/Output/01_Random_Formatted_Output.RData")
output <- random_formatted
names(output)
NetworkSummary <- function(networklist){
netwobjects <- lapply(networklist, function(x) network(x, directed = T))
netwstats <- data.frame(
"Network size" = mean(sapply(netwobjects, network.size)),
"Density" = mean(sapply(netwobjects, gden)),
"Components" = mean(sapply(netwobjects, components)),
"Transitivity" = mean(sapply(netwobjects, function(x) gtrans(x, mode = "graph"))),
"Reciprocity" = mean(sapply(netwobjects, function(x) grecip (x, measure = "edgewise")))
)
return(netwstats)
}
for (i in 1:ncol(error_combo)){
indices <- ((i-1)*(n)+1):n*i
obs_1 <- lapply(output$original_networks[indices], function(arr) arr[,,1])
obs_2 <- lapply(output$original_networks[indices], function(arr) arr[,,2])
an_1 <- lapply(output$analyzed_networks[indices], function(arr) arr[,,1])
an_2 <- lapply(output$analyzed_networks[indices], function(arr) arr[,,2])
print(NetworkSummary(obs_1))
}
error_combo <- expand.grid(neg_error, pos_error)
n <- 500
neg_error <- c()
pos_error <- 0
error_combo <- expand.grid(neg_error, pos_error)
for (i in 1:ncol(error_combo)){
indices <- ((i-1)*(n)+1):n*i
obs_1 <- lapply(output$original_networks[indices], function(arr) arr[,,1])
obs_2 <- lapply(output$original_networks[indices], function(arr) arr[,,2])
an_1 <- lapply(output$analyzed_networks[indices], function(arr) arr[,,1])
an_2 <- lapply(output$analyzed_networks[indices], function(arr) arr[,,2])
print(NetworkSummary(obs_1))
}
length(obs_1)
obs_1[[1]]
NetworkSummary(obs_1)
library(network)
library(RSiena)
library(dplyr)
library(ggplot2)
library(igraph)
library(sna)
library(network)
library(RColorBrewer)
library(GGally)
library(reshape2)
library(parallel)
?network
network(obs_1[[1]])
View(obs_1[[1]])
is(obs_1[[1]])
any(is.na(obs_1[[1]]))
network(obs_1[[1]])
network(obs_1[[1]], matrix.type = "adjacency")
NetworkSummary <- function(networklist){
netwobjects <- lapply(networklist, function(x) network(x, directed = T,
matrix.type = "adjacency"))
netwstats <- data.frame(
"Network size" = mean(sapply(netwobjects, network.size)),
"Density" = mean(sapply(netwobjects, gden)),
"Components" = mean(sapply(netwobjects, components)),
"Transitivity" = mean(sapply(netwobjects, function(x) gtrans(x, mode = "graph"))),
"Reciprocity" = mean(sapply(netwobjects, function(x) grecip (x, measure = "edgewise")))
)
return(netwstats)
}
for (i in 1:ncol(error_combo)){
indices <- ((i-1)*(n)+1):n*i
obs_1 <- lapply(output$original_networks[indices], function(arr) arr[,,1])
obs_2 <- lapply(output$original_networks[indices], function(arr) arr[,,2])
an_1 <- lapply(output$analyzed_networks[indices], function(arr) arr[,,1])
an_2 <- lapply(output$analyzed_networks[indices], function(arr) arr[,,2])
print(NetworkSummary(obs_1))
}
network(obs_1[[1]], directed = T, matrix.type = "adjacency")
lapply(obs_1, function(x) network(x, directed = T,
matrix.type = "adjacency"))
is(obs_1[[1]])
as.numeric(obs_1[[1]])
netwobjects <- lapply(networklist, function(x)
network(matrix(as.numeric(x), nrow = nrow(x)), directed = T, matrix.type = "adjacency"))
NetworkSummary <- function(networklist){
netwobjects <- lapply(networklist, function(x)
network(matrix(as.numeric(x), nrow = nrow(x)), directed = T, matrix.type = "adjacency"))
netwstats <- data.frame(
"Network size" = mean(sapply(netwobjects, network.size)),
"Density" = mean(sapply(netwobjects, gden)),
"Components" = mean(sapply(netwobjects, components)),
"Transitivity" = mean(sapply(netwobjects, function(x) gtrans(x, mode = "graph"))),
"Reciprocity" = mean(sapply(netwobjects, function(x) grecip (x, measure = "edgewise")))
)
return(netwstats)
}
NetworkSummary(obs_1)
View(matrix(as.numeric(obs_1[[1]]), nrow = nrow(obs_1[[1]])))
NetworkSummary <- function(networklist){
numerics <- apply(networklist, function(x) matrix(as.numeric(x), nrow = nrow(x)))
netwobjects <- lapply(networklist, function(x)
network(matrix(as.numeric(x), nrow = nrow(x)), directed = T, matrix.type = "adjacency"))
netwstats <- data.frame(
"Network size" = mean(sapply(netwobjects, network.size)),
"Density" = mean(sapply(netwobjects, gden)),
"Components" = mean(sapply(netwobjects, components)),
"Transitivity" = mean(sapply(netwobjects, function(x) gtrans(x, mode = "graph"))),
"Reciprocity" = mean(sapply(netwobjects, function(x) grecip (x, measure = "edgewise")))
)
return(netwstats)
}
numerics <- apply(networklist, function(x) matrix(as.numeric(x), nrow = nrow(x)))
numerics <- lapply(networklist, function(x) matrix(as.numeric(x), nrow = nrow(x)))
networklist <- obs_1[[1]]
numerics <- lapply(networklist, function(x) matrix(as.numeric(x), nrow = nrow(x)))
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# Load R Packages
library(RSiena)
library(dplyr)
library(ggplot2)
library(igraph)
library(sna)
library(network)
library(RColorBrewer)
library(GGally)
library(reshape2)
library(parallel)
# Load Data
load("../Data/Input/Glasgow-friendship.RData")
load("../Data/Input/Glasgow-demographic.RData")
# Source Scripts
source("./SimulationRun.R")
source("./HelperFunctions.R")
source("./FormatOutput.R")
# Only select actors that are active participants in both wave 2 and 3
noresponse_1 <- apply(friendship.2, 1, function(row) all(is.na(row) | row == 10))
noresponse_2 <- apply(friendship.3, 1, function(row) all(is.na(row) | row == 10))
inactive <- noresponse_1 | noresponse_2
netwmatrices <- list(friendship.2[!inactive, !inactive], friendship.3[!inactive, !inactive]) %>%
lapply(., function(x) apply(x,1, function(y) replace(y,y == 2, 1))) # Create network without weights
# Coding sex as 0/1
sex <- ifelse(sex.F[!inactive] == 1, 0, 1)
sex2 <- coCovar(sex, centered = F)
set.seed(2809)
controls <- sienaAlgorithmCreate(seed = 2809)
# Creating "Real" SAOM model & second observations generated based on the second model
if (file.exists("../Data/Output/RealModel.RData")){
realmodel <- readRDS("../Data/Output/RealModel.RData")
second_observations <- readRDS("../Data/Output/SecondObservations.RData")
} else{
# Real Model
friendship <- sienaDependent(array(c(netwmatrices[[1]], netwmatrices[[2]]),
dim = c(133,133,2)))
glasgowdata <- sienaDataCreate(friendship, sex2)
effects <- getEffects(glasgowdata)
effects <- includeEffects(effects, name = "friendship",
density, recip, cycle3, gwespFF, transRecTrip, inPop, inAct)
effects <- includeEffects(effects, name = "friendship", sameX, interaction1 = "sex2")
realmodel <- siena07(controls, data = glasgowdata, effects = effects)
# Second Observations
simulation_controls <- sienaAlgorithmCreate(n3 = 500, nsub = 0, seed = 2809)
simulations <- siena07(simulation_controls, data = glasgowdata, effects = effects,
returnDeps = T, prevAns = realmodel)
second_observations_list <- lapply(lapply(lapply(simulations$sims, "[[", "Data1"), "[[", "friendship"),
"[[", "1")
second_observations <- lapply(second_observations_list, function(x)
as_adjacency_matrix(graph_from_edgelist(as.matrix(x[,-3]), directed = T)))
saveRDS(realmodel, "../Data/Output/RealModel.RData")
saveRDS(second_observations, "../Data/Output/SecondObservations.RData")
}
n <- 500
neg_error <- c()
pos_error <- 0
simulation_element <- expand.grid(1:n, neg_error, pos_error)
cl <- makeCluster(detectCores()-1)
stopCluster(cl)
random_output <- readRDS("../Data/Output/01_Random_Raw_Output.RData")
random_formatted <- FormatOutput(random_output)
saveRDS(random_formatted, "../Data/Output/01_Random_Formatted_Output.RData")
stopCluster(cl)
random_output <- readRDS("../Data/Output/01_Random_Raw_Output.RData")
random_formatted <- FormatOutput(random_output)
saveRDS(random_formatted, "../Data/Output/01_Random_Formatted_Output.RData")
error_combo <- expand.grid(neg_error, pos_error)
output <- random_formatted
NetworkSummary <- function(networklist){
numerics <- lapply(networklist, function(x) matrix(as.numeric(x), nrow = nrow(x)))
netwobjects <- lapply(networklist, function(x)
network(matrix(as.numeric(x), nrow = nrow(x)), directed = T, matrix.type = "adjacency"))
netwstats <- data.frame(
"Network size" = mean(sapply(netwobjects, network.size)),
"Density" = mean(sapply(netwobjects, gden)),
"Components" = mean(sapply(netwobjects, components)),
"Transitivity" = mean(sapply(netwobjects, function(x) gtrans(x, mode = "graph"))),
"Reciprocity" = mean(sapply(netwobjects, function(x) grecip (x, measure = "edgewise")))
)
return(netwstats)
}
NetworkSummary <- function(networklist){
#numerics <- lapply(networklist, function(x) matrix(as.numeric(x), nrow = nrow(x)))
netwobjects <- lapply(networklist, function(x)
network(structure(as.numeric(x), dim = dim(x)), directed = T, matrix.type = "adjacency"))
netwstats <- data.frame(
"Network size" = mean(sapply(netwobjects, network.size)),
"Density" = mean(sapply(netwobjects, gden)),
"Components" = mean(sapply(netwobjects, components)),
"Transitivity" = mean(sapply(netwobjects, function(x) gtrans(x, mode = "graph"))),
"Reciprocity" = mean(sapply(netwobjects, function(x) grecip (x, measure = "edgewise")))
)
return(netwstats)
}
indices <- ((i-1)*(n)+1):n*i
for (i in 1:ncol(error_combo)){
indices <- ((i-1)*(n)+1):n*i
obs_1 <- lapply(output$original_networks[indices], function(arr) arr[,,1])
obs_2 <- lapply(output$original_networks[indices], function(arr) arr[,,2])
an_1 <- lapply(output$analyzed_networks[indices], function(arr) arr[,,1])
an_2 <- lapply(output$analyzed_networks[indices], function(arr) arr[,,2])
print(NetworkSummary(obs_1))
}
NetworkSummary <- function(networklist){
netwobjects <- lapply(networklist, function(x) matrix(as.numeric(x), nrow = nrow(x)))
#netwobjects <- lapply(networklist, function(x)
# network(structure(as.numeric(x), dim = dim(x)), directed = T, matrix.type = "adjacency"))
netwstats <- data.frame(
"Network size" = mean(sapply(netwobjects, network.size)),
"Density" = mean(sapply(netwobjects, gden)),
"Components" = mean(sapply(netwobjects, components)),
"Transitivity" = mean(sapply(netwobjects, function(x) gtrans(x, mode = "graph"))),
"Reciprocity" = mean(sapply(netwobjects, function(x) grecip (x, measure = "edgewise")))
)
return(netwstats)
}
for (i in 1:ncol(error_combo)){
indices <- ((i-1)*(n)+1):n*i
obs_1 <- lapply(output$original_networks[indices], function(arr) arr[,,1])
obs_2 <- lapply(output$original_networks[indices], function(arr) arr[,,2])
an_1 <- lapply(output$analyzed_networks[indices], function(arr) arr[,,1])
an_2 <- lapply(output$analyzed_networks[indices], function(arr) arr[,,2])
print(NetworkSummary(obs_1))
}
NetworkSummary <- function(networklist){
numerics <- lapply(networklist, function(x) matrix(as.numeric(x), nrow = nrow(x)))
netwobjects <- lapply(numerics, function(x)
network(x, directed = T, matrix.type = "adjacency"))
netwstats <- data.frame(
"Network size" = mean(sapply(netwobjects, network.size)),
"Density" = mean(sapply(netwobjects, gden)),
"Components" = mean(sapply(netwobjects, components)),
"Transitivity" = mean(sapply(netwobjects, function(x) gtrans(x, mode = "graph"))),
"Reciprocity" = mean(sapply(netwobjects, function(x) grecip (x, measure = "edgewise")))
)
return(netwstats)
}
for (i in 1:ncol(error_combo)){
indices <- ((i-1)*(n)+1):n*i
obs_1 <- lapply(output$original_networks[indices], function(arr) arr[,,1])
obs_2 <- lapply(output$original_networks[indices], function(arr) arr[,,2])
an_1 <- lapply(output$analyzed_networks[indices], function(arr) arr[,,1])
an_2 <- lapply(output$analyzed_networks[indices], function(arr) arr[,,2])
print(NetworkSummary(obs_1))
}
?matrix
for (i in 1:ncol(error_combo)){
indices2 <- ((i-1)*(n)+1):n*i
indices <- 1:2
obs_1 <- lapply(output$original_networks[indices], function(arr) arr[,,1])
obs_2 <- lapply(output$original_networks[indices], function(arr) arr[,,2])
an_1 <- lapply(output$analyzed_networks[indices], function(arr) arr[,,1])
an_2 <- lapply(output$analyzed_networks[indices], function(arr) arr[,,2])
print(NetworkSummary(obs_1))
}
indices
for (i in 1:ncol(error_combo)){
indices <- ((i-1)*(n)+1):n*i
obs_1 <- lapply(output$original_networks[indices], function(arr) arr[,,1])
obs_2 <- lapply(output$original_networks[indices], function(arr) arr[,,2])
an_1 <- lapply(output$analyzed_networks[indices], function(arr) arr[,,1])
an_2 <- lapply(output$analyzed_networks[indices], function(arr) arr[,,2])
print(NetworkSummary(obs_1))
}
indices <- 1:500
for (i in 1:ncol(error_combo)){
indices2 <- ((i-1)*(n)+1):n*i
indices <- 1:500
obs_1 <- lapply(output$original_networks[indices], function(arr) arr[,,1])
obs_2 <- lapply(output$original_networks[indices], function(arr) arr[,,2])
an_1 <- lapply(output$analyzed_networks[indices], function(arr) arr[,,1])
an_2 <- lapply(output$analyzed_networks[indices], function(arr) arr[,,2])
print(NetworkSummary(obs_1))
}
indices <- 1:100
for (i in 1:ncol(error_combo)){
indices2 <- ((i-1)*(n)+1):n*i
indices <- 1:100
obs_1 <- lapply(output$original_networks[indices], function(arr) arr[,,1])
obs_2 <- lapply(output$original_networks[indices], function(arr) arr[,,2])
an_1 <- lapply(output$analyzed_networks[indices], function(arr) arr[,,1])
an_2 <- lapply(output$analyzed_networks[indices], function(arr) arr[,,2])
print(NetworkSummary(obs_1))
}
indices <- 1:50
for (i in 1:ncol(error_combo)){
indices2 <- ((i-1)*(n)+1):n*i
indices <- 1:50
obs_1 <- lapply(output$original_networks[indices], function(arr) arr[,,1])
obs_2 <- lapply(output$original_networks[indices], function(arr) arr[,,2])
an_1 <- lapply(output$analyzed_networks[indices], function(arr) arr[,,1])
an_2 <- lapply(output$analyzed_networks[indices], function(arr) arr[,,2])
print(NetworkSummary(obs_1))
}
for (i in 1:ncol(error_combo)){
indices2 <- ((i-1)*(n)+1):n*i
indices <- 1:50
obs_1 <- lapply(output$original_networks[indices], function(arr) arr[,,1])
obs_2 <- lapply(output$original_networks[indices], function(arr) arr[,,2])
an_1 <- lapply(output$analyzed_networks[indices], function(arr) arr[,,1])
an_2 <- lapply(output$analyzed_networks[indices], function(arr) arr[,,2])
print(NetworkSummary(obs_1))
}
indices
obs_1
length(obs_1)
NetworkSummary(obs_1)
length(obs_1)
indices <- 1:75
obs_1 <- lapply(output$original_networks[indices], function(arr) arr[,,1])
print(NetworkSummary(obs_1))
indices <- 1:55
obs_1 <- lapply(output$original_networks[indices], function(arr) arr[,,1])
print(NetworkSummary(obs_1))
indices <- 1:60
obs_1 <- lapply(output$original_networks[indices], function(arr) arr[,,1])
print(NetworkSummary(obs_1))
indices <- 1:65
obs_1 <- lapply(output$original_networks[indices], function(arr) arr[,,1])
print(NetworkSummary(obs_1))
length(obs_1)
indices <- 1:70
obs_1 <- lapply(output$original_networks[indices], function(arr) arr[,,1])
print(NetworkSummary(obs_1))
indices <- 1:75
obs_1 <- lapply(output$original_networks[indices], function(arr) arr[,,1])
print(NetworkSummary(obs_1))
indices <- 1:71
obs_1 <- lapply(output$original_networks[indices], function(arr) arr[,,1])
print(NetworkSummary(obs_1))
indices <- 1:70
obs_1 <- lapply(output$original_networks[indices], function(arr) arr[,,1])
print(NetworkSummary(obs_1))
View(obs_1[71])
View(obs_1[72])
View(obs_1[70])
indices <- 1:75
obs_1 <- lapply(output$original_networks[indices], function(arr) arr[,,1])
View(obs_1[71])
length(output$original_networks)
n <- 500
neg_error <- c()
pos_error <- 0
neg_error <- c(0.1)
random_output <- readRDS("../Data/Output/01_Random_Raw_Output.RData")
length(random_formatted$original_networks)
length(random_formatted$analyzed_networks)
length(second_observations)
n <- 500
neg_error <- c(0.1)
pos_error <- 0
simulation_element <- expand.grid(1:n, neg_error, pos_error)
simulation_element
n <- 500
neg_error <- c(0.1)
pos_error <- 0
simulation_element <- expand.grid(1:n, neg_error, pos_error)
cl <- makeCluster(detectCores()-1)
clusterExport(cl, c("SimulationRun", "IntroduceError_Random", "second_observations", "netwmatrices", "sex2", "controls", "simulation_element", "ChangeCoding"))
clusterEvalQ(cl, {library(igraph); library(RSiena)})
random_output <- parApply(cl, MARGIN = 1, X = as.matrix(simulation_element), FUN = function(x) SimulationRun(IntroduceError_Random, netwmatrices[[1]], second_observations[[x[1]]], sex2, controls, x[3], x[2]))
updateR()
library(installr)
install.packages("installr")
library(installr)
updateR()
